import RAL from './ral';
export declare class ComponentModelTrap extends Error {
    constructor(message: string);
}
export declare enum Alignment {
    byte = 1,
    halfWord = 2,
    word = 4,
    doubleWord = 8
}
export declare namespace Alignment {
    function align(ptr: ptr, alignment: Alignment): size;
    function getAlignment(ptr: ptr): Alignment;
}
export interface Memory {
    readonly id: string;
    readonly buffer: ArrayBuffer;
    alloc(align: Alignment, size: size): MemoryRange;
    realloc(range: MemoryRange, align: Alignment, newSize: size): MemoryRange;
    preAllocated(ptr: ptr, size: size): MemoryRange;
    readonly(ptr: ptr, size: size): ReadonlyMemoryRange;
    free?(range: MemoryRange): void;
}
export declare class MemoryError extends ComponentModelTrap {
    constructor(message: string);
}
type ArrayClazz<T extends ArrayLike<number> & {
    set(array: ArrayLike<number>, offset?: number): void;
}> = {
    new (buffer: ArrayBuffer, byteOffset: number, length: number): T;
    new (length: number): T;
    BYTES_PER_ELEMENT: number;
};
type BigArrayClazz<T extends ArrayLike<bigint> & {
    set(array: ArrayLike<bigint>, offset?: number): void;
}> = {
    new (buffer: ArrayBuffer, byteOffset: number, length: number): T;
    new (length: number): T;
    BYTES_PER_ELEMENT: number;
};
export type offset<_T = undefined> = u32;
export declare abstract class BaseMemoryRange {
    protected readonly _memory: Memory;
    private readonly _ptr;
    private readonly _size;
    private readonly _alignment;
    private _view;
    protected constructor(memory: Memory, ptr: ptr, size: size);
    get memory(): Memory;
    get ptr(): ptr;
    get size(): size;
    get alignment(): Alignment;
    protected get view(): DataView;
    getUint8(offset: offset<u8>): u8;
    getInt8(offset: offset<s8>): s8;
    getUint16(offset: offset<u16>): u16;
    getInt16(offset: offset<s16>): s16;
    getUint32(offset: offset<u32>): u32;
    getInt32(offset: offset<s32>): s32;
    getUint64(offset: offset<u64>): u64;
    getInt64(offset: offset<s64>): s64;
    getFloat32(offset: offset<f32>): f32;
    getFloat64(offset: offset<f64>): f64;
    getPtr(offset: offset<ptr>): ptr;
    getUint8Array(offset: offset, length?: size | undefined): Uint8Array;
    getInt8Array(offset: offset, length?: size | undefined): Int8Array;
    getUint16Array(byteOffset: offset, length?: size | undefined): Uint16Array;
    getInt16Array(byteOffset: offset, length?: size | undefined): Int16Array;
    getUint32Array(byteOffset: offset, length?: size | undefined): Uint32Array;
    getInt32Array(byteOffset: offset, length?: size | undefined): Int32Array;
    getUint64Array(byteOffset: offset, length?: size | undefined): BigUint64Array;
    getInt64Array(byteOffset: offset, length?: size | undefined): BigInt64Array;
    getFloat32Array(byteOffset: offset, length?: size | undefined): Float32Array;
    getFloat64Array(byteOffset: offset, length?: size | undefined): Float64Array;
    copyBytes(offset: offset, length: size, into: MemoryRange, into_offset: size): void;
    assertAlignment(offset: offset, alignment: Alignment): void;
    getArray<T extends ArrayLike<number> & {
        set(array: ArrayLike<number>, offset?: number): void;
    }>(byteOffset: offset, length: size | undefined, clazz: ArrayClazz<T>): T;
    getBigArray<T extends ArrayLike<bigint> & {
        set(array: ArrayLike<bigint>, offset?: number): void;
    }>(byteOffset: offset, length: size | undefined, clazz: BigArrayClazz<T>): T;
}
export declare class ReadonlyMemoryRange extends BaseMemoryRange {
    constructor(memory: Memory, ptr: ptr, size: size);
    range(offset: offset, size: size): ReadonlyMemoryRange;
}
export declare class MemoryRange extends BaseMemoryRange {
    readonly isAllocated: boolean;
    constructor(memory: Memory, ptr: ptr, size: size, isPreallocated?: boolean);
    free(): void;
    range(offset: offset, size: size): MemoryRange;
    setUint8(offset: offset<u8>, value: u8): void;
    setInt8(offset: offset<s8>, value: s8): void;
    setUint16(offset: offset<u16>, value: u16): void;
    setInt16(offset: offset<s16>, value: s16): void;
    setUint32(offset: offset<u32>, value: u32): void;
    setInt32(offset: offset<s32>, value: s32): void;
    setUint64(offset: offset<u64>, value: u64): void;
    setInt64(offset: offset<s64>, value: s64): void;
    setFloat32(offset: offset<f32>, value: f32): void;
    setFloat64(offset: offset<f64>, value: f64): void;
    setPtr(offset: offset<ptr>, value: ptr): void;
    getUint8View(offset: offset, length?: size | undefined): Uint8Array;
    getInt8View(offset: offset, length?: size | undefined): Int8Array;
    getUint16View(offset: offset, length?: size | undefined): Uint16Array;
    getInt16View(offset: offset, length?: size | undefined): Int16Array;
    getUint32View(offset: offset, length?: size | undefined): Uint32Array;
    getInt32View(offset: offset, length?: size | undefined): Int32Array;
    getUint64View(offset: offset, length?: size | undefined): BigUint64Array;
    getInt64View(offset: offset, length?: size | undefined): BigInt64Array;
    getFloat32View(offset: offset, length?: size | undefined): Float32Array;
    getFloat64View(offset: offset, length?: size | undefined): Float64Array;
    setUint8Array(offset: offset, bytes: Uint8Array): void;
    setInt8Array(offset: offset, bytes: Int8Array): void;
    setUint16Array(offset: offset, bytes: Uint16Array): void;
    setInt16Array(offset: offset, bytes: Int16Array): void;
    setUint32Array(offset: offset, bytes: Uint32Array): void;
    setInt32Array(offset: offset, bytes: Int32Array): void;
    setUint64Array(offset: offset, bytes: BigUint64Array): void;
    setInt64Array(offset: offset, bytes: BigInt64Array): void;
    setFloat32Array(offset: offset, bytes: Float32Array): void;
    setFloat64Array(offset: offset, bytes: Float64Array): void;
    private getArrayView;
    private getBigArrayView;
    private setArray;
    private setBigArray;
}
/**
 * A memory of size 0. Doesn't allow any kind of operation on it.
 */
declare class NullMemory implements Memory {
    readonly id: string;
    readonly buffer: ArrayBuffer;
    alloc(): MemoryRange;
    realloc(): MemoryRange;
    preAllocated(): MemoryRange;
    readonly(): ReadonlyMemoryRange;
    free(): void;
}
export type MemoryExports = {
    memory: {
        buffer: ArrayBuffer;
    };
    cabi_realloc: (orig: ptr, orig_size: size, orig_align: size, new_size: size) => ptr;
};
export declare namespace Memory {
    const Null: NullMemory;
    class Default implements Memory {
        readonly id: string;
        private readonly memory;
        private readonly cabi_realloc;
        constructor(exports: Record<string, any>, id?: string);
        get buffer(): ArrayBuffer;
        alloc(align: Alignment, size: number): MemoryRange;
        realloc(range: MemoryRange, newSize: size): MemoryRange;
        preAllocated(ptr: ptr, size: size): MemoryRange;
        readonly(ptr: ptr, size: size): ReadonlyMemoryRange;
    }
}
export type Encodings = 'utf-8' | 'utf-16' | 'latin1+utf-16';
export interface Options {
    encoding: Encodings;
    keepOption?: boolean;
}
export declare namespace Options {
    function is(value: any): value is Options;
}
export declare enum FlatTypeKind {
    i32 = "i32",
    i64 = "i64",
    f32 = "f32",
    f64 = "f64"
}
export interface FlatType<F extends i32 | i64 | f32 | f64> {
    readonly kind: FlatTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    load(memory: ReadonlyMemoryRange, offset: offset): F;
    store(memory: MemoryRange, offset: offset, value: F): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset): void;
}
export type i32 = number;
export declare const i32: FlatType<i32>;
export type i64 = bigint;
export declare const i64: FlatType<i64>;
export type f32 = number;
export declare const f32: FlatType<f32>;
export type f64 = number;
export declare const f64: FlatType<f64>;
export type WasmType = i32 | i64 | f32 | f64;
type GenericFlatType = FlatType<WasmType>;
export declare class FlatTuple {
    private readonly types;
    readonly alignment: Alignment;
    readonly size: size;
    constructor(types: readonly GenericFlatType[]);
    load(memory: ReadonlyMemoryRange, offset: size): readonly WasmType[];
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: size, values: readonly WasmType[]): void;
    copy(dest: MemoryRange, dest_offset: size, src: ReadonlyMemoryRange, src_offset: size): void;
    private static alignment;
    private static size;
}
export type FlatValuesIter = Iterator<WasmType, WasmType>;
export declare enum ComponentModelTypeKind {
    bool = "bool",
    u8 = "u8",
    u16 = "u16",
    u32 = "u32",
    u64 = "u64",
    s8 = "s8",
    s16 = "s16",
    s32 = "s32",
    s64 = "s64",
    float32 = "float32",
    float64 = "float64",
    char = "char",
    string = "string",
    list = "list",
    record = "record",
    tuple = "tuple",
    variant = "variant",
    enum = "enum",
    flags = "flags",
    option = "option",
    result = "result",
    resource = "resource",
    resourceHandle = "resourceHandle",
    borrow = "borrow",
    own = "own"
}
export interface ComponentModelContext {
    readonly options: Options;
    readonly resources: ResourceManagers;
}
export declare namespace ComponentModelContext {
    function is(value: any): value is ComponentModelContext;
}
export interface ComponentModelType<J> {
    readonly kind: ComponentModelTypeKind;
    readonly size: number;
    readonly alignment: Alignment;
    readonly flatTypes: ReadonlyArray<GenericFlatType>;
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): J;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): J;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, value: J, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, value: J, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
}
export type AnyComponentModelType = ComponentModelType<JType>;
export declare class ResultError<V extends JType> extends Error {
    readonly cause: V;
    constructor(message: string, cause: V);
}
interface ResultErrorConstructor<V extends JType> {
    new (value: V): ResultError<V>;
}
export type bool = number;
export declare namespace bool {
    const kind: ComponentModelTypeKind;
    const size: number;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<bool>): boolean;
    function liftFlat(_memory: Memory, values: FlatValuesIter): boolean;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<bool>, value: boolean): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: boolean): void;
    function copy(dest: MemoryRange, dest_offset: offset<bool>, src: ReadonlyMemoryRange, src_offset: offset<bool>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<boolean> {
        constructor(cause: boolean);
    }
}
export type u8 = number;
export declare namespace u8 {
    const kind: ComponentModelTypeKind;
    const size = 1;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    const LOW_VALUE = 0;
    const HIGH_VALUE = 255;
    function load(memory: ReadonlyMemoryRange, offset: offset<u8>): u8;
    function liftFlat(_memory: Memory, values: FlatValuesIter): u8;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<u8>, value: u8): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: u8): void;
    function copy(dest: MemoryRange, dest_offset: offset<u8>, src: ReadonlyMemoryRange, src_offset: offset<u8>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<u8> {
        constructor(cause: u8);
    }
}
export type u16 = number;
export declare namespace u16 {
    const kind: ComponentModelTypeKind;
    const size = 2;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    const LOW_VALUE = 0;
    const HIGH_VALUE = 65535;
    function load(memory: ReadonlyMemoryRange, offset: offset<u16>): u16;
    function liftFlat(_memory: Memory, values: FlatValuesIter): u16;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<u16>, value: u16): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<u16>, src: ReadonlyMemoryRange, src_offset: offset<u16>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<u16> {
        constructor(cause: u16);
    }
}
export type u32 = number;
export declare namespace u32 {
    const kind: ComponentModelTypeKind;
    const size = 4;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    const LOW_VALUE = 0;
    const HIGH_VALUE = 4294967295;
    function valid(value: u32): boolean;
    function load(memory: ReadonlyMemoryRange, offset: offset<u32>): u32;
    function liftFlat(_memory: Memory, values: FlatValuesIter): u32;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<u32>, value: u32): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<u32>, src: ReadonlyMemoryRange, src_offset: offset<u32>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<u32> {
        constructor(cause: u32);
    }
}
export type u64 = bigint;
export declare namespace u64 {
    const kind: ComponentModelTypeKind;
    const size = 8;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    const LOW_VALUE = 0n;
    const HIGH_VALUE = 18446744073709551615n;
    function load(memory: ReadonlyMemoryRange, offset: offset<u64>): u64;
    function liftFlat(_memory: Memory, values: FlatValuesIter): u64;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<u64>, value: u64): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: bigint): void;
    function copy(dest: MemoryRange, dest_offset: offset<u64>, src: ReadonlyMemoryRange, src_offset: offset<u64>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<u64> {
        constructor(cause: u64);
    }
}
export type s8 = number;
export declare namespace s8 {
    const kind: ComponentModelTypeKind;
    const size = 1;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<s8>): s8;
    function liftFlat(_memory: Memory, values: FlatValuesIter): s8;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<s8>, value: s8): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<u64>, src: ReadonlyMemoryRange, src_offset: offset<u64>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<s8> {
        constructor(cause: s8);
    }
}
export type s16 = number;
export declare namespace s16 {
    const kind: ComponentModelTypeKind;
    const size = 2;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<16>): s16;
    function liftFlat(_memory: Memory, values: FlatValuesIter): s16;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<s16>, value: s16): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<s16>, src: ReadonlyMemoryRange, src_offset: offset<s16>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<s16> {
        constructor(cause: s16);
    }
}
export type s32 = number;
export declare namespace s32 {
    const kind: ComponentModelTypeKind;
    const size = 4;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<32>): s32;
    function liftFlat(_memory: Memory, values: FlatValuesIter): s32;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<32>, value: s32): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<s32>, src: ReadonlyMemoryRange, src_offset: offset<s32>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<s32> {
        constructor(cause: s32);
    }
}
export type s64 = bigint;
export declare namespace s64 {
    const kind: ComponentModelTypeKind;
    const size = 8;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<s64>): s64;
    function liftFlat(_memory: Memory, values: FlatValuesIter): s64;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<s64>, value: s64): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: bigint): void;
    function copy(dest: MemoryRange, dest_offset: offset<s64>, src: ReadonlyMemoryRange, src_offset: offset<s64>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<s64> {
        constructor(cause: s64);
    }
}
export type float32 = number;
export declare namespace float32 {
    const kind: ComponentModelTypeKind;
    const size = 4;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<float32>): float32;
    function liftFlat(_memory: Memory, values: FlatValuesIter): float32;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<float32>, value: float32): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<float32>, src: ReadonlyMemoryRange, src_offset: offset<float32>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<float32> {
        constructor(cause: float32);
    }
}
export type float64 = number;
export declare namespace float64 {
    const kind: ComponentModelTypeKind;
    const size = 8;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<float64>): float64;
    function liftFlat(_memory: Memory, values: FlatValuesIter): float64;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<float64>, value: float64): void;
    function lowerFlat(result: WasmType[], _memory: Memory, value: number): void;
    function copy(dest: MemoryRange, dest_offset: offset<float64>, src: ReadonlyMemoryRange, src_offset: offset<float64>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<float64> {
        constructor(cause: float64);
    }
}
export type byte = u8;
export declare const byte: ComponentModelType<byte>;
export type size = u32;
export declare const size: ComponentModelType<size>;
export type ptr<_type = ArrayBuffer> = u32;
export declare const ptr: ComponentModelType<size>;
export declare namespace char {
    const kind: ComponentModelTypeKind;
    const size = 4;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memory: ReadonlyMemoryRange, offset: offset<u32>, _context: ComponentModelContext): string;
    function liftFlat(memory: Memory, values: FlatValuesIter, _context: ComponentModelContext): string;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<u32>, value: string, _context: ComponentModelContext): void;
    function lowerFlat(result: WasmType[], memory: Memory, value: string, _context: ComponentModelContext): void;
    function copy(dest: MemoryRange, dest_offset: offset<u32>, src: ReadonlyMemoryRange, src_offset: offset<u32>): void;
    function copyFlat(result: WasmType[], _dest: Memory, values: FlatValuesIter, _src: Memory): void;
    class Error extends ResultError<string> {
        constructor(value: string);
    }
}
export declare namespace wstring {
    const kind: ComponentModelTypeKind;
    const size = 8;
    const alignment: Alignment;
    const flatTypes: ReadonlyArray<GenericFlatType>;
    function load(memRange: ReadonlyMemoryRange, offset: offset<[u32, u32]>, context: ComponentModelContext): string;
    function liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): string;
    function alloc(memory: Memory): MemoryRange;
    function store(memory: MemoryRange, offset: offset<[u32, u32]>, str: string, context: ComponentModelContext): void;
    function lowerFlat(result: WasmType[], memory: Memory, str: string, context: ComponentModelContext): void;
    function copy(dest: MemoryRange, dest_offset: offset<[u32, u32]>, src: ReadonlyMemoryRange, src_offset: offset<[u32, u32]>, context: ComponentModelContext): void;
    function copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
    function getAlignmentAndByteLength(codeUnits: u32, options: Options): [Alignment, number];
    class Error extends ResultError<string> {
        constructor(value: string);
    }
}
export type JArray = JType[];
export declare class ListType<T> implements ComponentModelType<T[]> {
    private static readonly offsets;
    readonly elementType: ComponentModelType<T>;
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: ReadonlyArray<GenericFlatType>;
    constructor(elementType: ComponentModelType<T>);
    load(memRange: ReadonlyMemoryRange, offset: offset<[u32, u32]>, context: ComponentModelContext): T[];
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T[];
    alloc(memory: Memory): MemoryRange;
    store(memRange: MemoryRange, offset: offset<[u32, u32]>, values: T[], context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, values: T[], context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset<[u32, u32]>, src: ReadonlyMemoryRange, src_offset: offset<[u32, u32]>): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, _context: ComponentModelContext): void;
    private loadFromRange;
    private storeIntoRange;
}
export declare namespace list {
    class Error extends ResultError<JType[]> {
        constructor(cause: JType[]);
    }
}
declare abstract class TypeArrayType<T extends {
    length: number;
    byteLength: number;
}, ET> implements ComponentModelType<T> {
    private static readonly offsets;
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: ReadonlyArray<GenericFlatType>;
    protected readonly elementType: ComponentModelType<ET>;
    constructor(elementType: ComponentModelType<ET>);
    load(memRange: ReadonlyMemoryRange, offset: offset): T;
    liftFlat(memory: Memory, values: FlatValuesIter): T;
    alloc(memory: Memory): MemoryRange;
    store(memRange: MemoryRange, offset: offset, value: T): void;
    lowerFlat(result: WasmType[], memory: Memory, value: T): void;
    copy(dest: MemoryRange, dest_offset: ptr<u8>, src: ReadonlyMemoryRange, src_offset: ptr<u8>): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, _context: ComponentModelContext): void;
    protected abstract loadFromRange(memory: ReadonlyMemoryRange, length: number): T;
    protected abstract storeIntoRange(memory: MemoryRange, value: T): void;
}
export declare class Int8ArrayType extends TypeArrayType<Int8Array, s8> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Int8Array;
    protected storeIntoRange(memory: MemoryRange, value: Int8Array): void;
}
export declare namespace Int8ArrayType {
    class Error extends ResultError<Int8Array> {
        constructor(cause: Int8Array);
    }
}
export declare class Int16ArrayType extends TypeArrayType<Int16Array, s16> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Int16Array;
    protected storeIntoRange(memory: MemoryRange, value: Int16Array): void;
}
export declare namespace Int16ArrayType {
    class Error extends ResultError<Int16Array> {
        constructor(cause: Int16Array);
    }
}
export declare class Int32ArrayType extends TypeArrayType<Int32Array, s32> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Int32Array;
    protected storeIntoRange(memory: MemoryRange, value: Int32Array): void;
}
export declare namespace Int32ArrayType {
    class Error extends ResultError<Int32Array> {
        constructor(cause: Int32Array);
    }
}
export declare class BigInt64ArrayType extends TypeArrayType<BigInt64Array, s64> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): BigInt64Array;
    protected storeIntoRange(memory: MemoryRange, value: BigInt64Array): void;
}
export declare namespace BigInt64ArrayType {
    class Error extends ResultError<BigInt64Array> {
        constructor(cause: BigInt64Array);
    }
}
export declare class Uint8ArrayType extends TypeArrayType<Uint8Array, u8> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Uint8Array;
    protected storeIntoRange(memory: MemoryRange, value: Uint8Array): void;
}
export declare namespace Uint8ArrayType {
    class Error extends ResultError<Uint8Array> {
        constructor(cause: Uint8Array);
    }
}
export declare class Uint16ArrayType extends TypeArrayType<Uint16Array, u16> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Uint16Array;
    protected storeIntoRange(memory: MemoryRange, value: Uint16Array): void;
}
export declare namespace Uint16ArrayType {
    class Error extends ResultError<Uint16Array> {
        constructor(cause: Uint16Array);
    }
}
export declare class Uint32ArrayType extends TypeArrayType<Uint32Array, u32> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Uint32Array;
    protected storeIntoRange(memory: MemoryRange, value: Uint32Array): void;
}
export declare namespace Uint32ArrayType {
    class Error extends ResultError<Uint32Array> {
        constructor(cause: Uint32Array);
    }
}
export declare class BigUint64ArrayType extends TypeArrayType<BigUint64Array, u64> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): BigUint64Array;
    protected storeIntoRange(memory: MemoryRange, value: BigUint64Array): void;
}
export declare namespace BigUint64ArrayType {
    class Error extends ResultError<BigUint64Array> {
        constructor(cause: BigUint64Array);
    }
}
export declare class Float32ArrayType extends TypeArrayType<Float32Array, float32> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Float32Array;
    protected storeIntoRange(memory: MemoryRange, value: Float32Array): void;
}
export declare namespace Float32ArrayType {
    class Error extends ResultError<Float32Array> {
        constructor(cause: Float32Array);
    }
}
export declare class Float64ArrayType extends TypeArrayType<Float64Array, float64> {
    constructor();
    protected loadFromRange(memory: ReadonlyMemoryRange, length: number): Float64Array;
    protected storeIntoRange(memory: MemoryRange, value: Float64Array): void;
}
export declare namespace Float64ArrayType {
    class Error extends ResultError<Float64Array> {
        constructor(cause: Float64Array);
    }
}
interface TypedField {
    readonly type: AnyComponentModelType;
}
interface JRecord {
    [key: string]: JType | undefined;
}
type JTuple = JType[];
declare abstract class BaseRecordType<T extends JRecord | JTuple, F extends TypedField> implements ComponentModelType<T> {
    fields: F[];
    kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: ReadonlyArray<GenericFlatType>;
    constructor(fields: F[], kind: ComponentModelTypeKind.record | ComponentModelTypeKind.tuple);
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): T;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, record: T, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, record: T, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
    protected abstract create(fields: F[], values: JType[]): T;
    protected abstract elements(record: T, fields: F[]): JType[];
    private static size;
    private static alignment;
    private static flatTypes;
}
interface RecordField extends TypedField {
    readonly name: string;
}
declare namespace RecordField {
    function create(name: string, type: AnyComponentModelType): RecordField;
}
export declare class RecordType<T extends JRecord> extends BaseRecordType<T, RecordField> {
    constructor(fields: [string, AnyComponentModelType][]);
    protected create(fields: RecordField[], values: JType[]): T;
    protected elements(record: T, fields: RecordField[]): JType[];
}
interface TupleField extends TypedField {
}
declare namespace TupleField {
    function create(type: AnyComponentModelType): TupleField;
}
export declare class TupleType<T extends JTuple> extends BaseRecordType<T, TupleField> {
    constructor(fields: AnyComponentModelType[]);
    protected create(_fields: TupleField[], values: JType[]): T;
    protected elements(record: T, _fields: TupleField[]): JType[];
}
export declare namespace tuple {
    class Error extends ResultError<JType[]> {
        constructor(cause: JType[]);
    }
}
export declare class FlagsType<_T> implements ComponentModelType<u32 | bigint> {
    readonly type: AnyComponentModelType | undefined;
    private readonly arraySize;
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: ReadonlyArray<GenericFlatType>;
    constructor(numberOfFlags: number);
    load(memory: ReadonlyMemoryRange, offset: offset<u8 | u16 | u32 | u32[]>, context: ComponentModelContext): u32 | bigint;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): u32 | bigint;
    private loadFrom;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset<u8 | u16 | u32 | u32[]>, flags: u32 | bigint, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], _memory: Memory, flags: u32 | bigint, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
    private storeInto;
    private static size;
    private static alignment;
    private static getType;
    private static flatTypes;
    private static num32Flags;
}
interface VariantCase {
    readonly index: u32;
    readonly tag: string;
    readonly type: AnyComponentModelType | undefined;
    readonly wantFlatTypes: GenericFlatType[] | undefined;
}
declare namespace VariantCase {
    function create(index: number, tag: string, type: AnyComponentModelType | undefined): VariantCase;
}
interface JVariantCase {
    readonly tag: string;
    readonly value?: JType | undefined | void;
}
export declare class VariantType<T extends JVariantCase, I, V extends JType> implements ComponentModelType<T> {
    readonly cases: VariantCase[];
    private readonly case2Index;
    private readonly ctor;
    private readonly discriminantType;
    private readonly maxCaseAlignment;
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: ReadonlyArray<GenericFlatType>;
    constructor(variants: [string, (AnyComponentModelType | undefined)][], ctor: (caseIndex: I, value: V) => T, kind?: ComponentModelTypeKind.variant | ComponentModelTypeKind.result);
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): T;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, variantValue: T, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, variantValue: T, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
    private static size;
    private static alignment;
    private static flatTypes;
    private static discriminantType;
    private static maxCaseAlignment;
    private static maxCaseSize;
    private static joinFlatType;
}
export type JEnum = string;
export declare class EnumType<T extends JEnum> implements ComponentModelType<T> {
    private readonly discriminantType;
    private readonly cases;
    private readonly case2index;
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: readonly GenericFlatType[];
    constructor(cases: string[]);
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): T;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, value: T, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, value: T, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
    private assertRange;
    private static discriminantType;
}
export declare namespace option {
    export const none: "none";
    export type None<T extends JType> = {
        readonly tag: typeof none;
    } & _common<T>;
    export function None<T extends JType>(): None<T>;
    export const some: "some";
    export type Some<T extends JType> = {
        readonly tag: typeof some;
        readonly value: T;
    } & _common<T>;
    export function Some<T extends JType>(value: T): Some<T>;
    export type _tt = typeof none | typeof some;
    export type _vt<T extends JType> = undefined | T;
    type _common<T extends JType> = Omit<OptionImpl<T>, 'case' | 'value'>;
    export function _ctor<T extends JType>(c: _tt, v: _vt<T>): option<T>;
    export function isOption<T extends JType>(value: T | option<T>): value is option<T>;
    class OptionImpl<T extends JType> {
        private readonly _tag;
        private readonly _value?;
        constructor(tag: typeof option.none | typeof option.some, value: undefined | T);
        get tag(): typeof option.none | typeof option.some;
        get value(): undefined | T;
        isNone(): this is None<T>;
        isSome(): this is Some<T>;
    }
    export class Error extends ResultError<JType> {
        constructor(cause: JType);
    }
    export {};
}
export type option<T extends JType> = option.None<T> | option.Some<T>;
export declare class OptionType<T extends JType> implements ComponentModelType<T | option<T> | undefined> {
    readonly valueType: AnyComponentModelType;
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: readonly GenericFlatType[];
    constructor(valueType: AnyComponentModelType);
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): T | option<T> | undefined;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T | option<T> | undefined;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, value: T | option<T> | undefined, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, value: T | option<T> | undefined, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
    private asOptionValue;
    private computeSize;
    private computeAlignment;
    private computeFlatTypes;
}
export declare namespace result {
    export const ok: "ok";
    export type Ok<O extends JType, E extends JType> = {
        readonly tag: typeof ok;
        readonly value: O;
    } & _common<O, E>;
    export function Ok<O extends JType, E extends JType>(value: O): Ok<O, E>;
    export const error: "error";
    export type Error<O extends JType, E extends JType> = {
        readonly tag: typeof error;
        readonly value: E;
    } & _common<O, E>;
    export function Error<O extends JType, E extends JType>(value: E): Error<O, E>;
    export type _tt = typeof ok | typeof error;
    export type _vt<O extends JType, E extends JType> = O | E;
    type _common<O extends JType, E extends JType> = Omit<ResultImpl<O, E>, 'tag' | 'value'>;
    export function _ctor<O extends JType, E extends JType>(c: _tt, v: _vt<O, E>): result<O, E>;
    export class ResultImpl<O extends JType, E extends JType> implements JVariantCase {
        private readonly _tag;
        private readonly _value;
        constructor(tag: _tt, value: _vt<O, E>);
        get tag(): _tt;
        get value(): _vt<O, E>;
        isOk(): this is Ok<O, E>;
        isError(): this is Error<O, E>;
    }
    export {};
}
export type result<O extends JType, E extends JType = void> = result.Ok<O, E> | result.Error<O, E>;
export declare class ResultType<O extends JType, E extends JType = void> extends VariantType<result<O, E>, 'ok' | 'error', O | E> {
    private readonly _errorClass;
    constructor(okType: AnyComponentModelType | undefined, errorType: AnyComponentModelType | undefined, errorClass?: ResultErrorConstructor<E>);
    get errorClass(): ResultErrorConstructor<E> | undefined;
}
export interface Resource {
    $handle(): ResourceHandle<this>;
}
export declare namespace Resource {
    class Default implements Resource {
        private _handle;
        constructor(handle: ResourceHandle);
        constructor(manager: ResourceManager);
        $handle(): ResourceHandle<this>;
    }
    function getRepresentation(resource: Resource & {
        $rep?(): ResourceRepresentation;
    }): ResourceRepresentation | undefined;
}
export type ResourceRepresentation = u32;
export interface ResourceManager<T extends Resource = Resource> {
    /** [resource-new]${resource} */
    newHandle(rep: ResourceRepresentation): ResourceHandle<T>;
    /** [resource-rep]${resource} */
    getRepresentation(handle: ResourceHandle<T>): ResourceRepresentation;
    /** [resource-drop]${resource} */
    dropHandle(handle: ResourceHandle<T>): ResourceRepresentation;
    setProxyInfo(ctor: (new (handleTag: symbol, handle: ResourceHandle<T>, rep: ResourceRepresentation) => T), dtor: (self: ResourceHandle<T>) => void): void;
    hasResource(handle: ResourceHandle<T>): boolean;
    getResource(handle: ResourceHandle<T>): T;
    registerResource(resource: T, handle?: ResourceHandle<T>): ResourceHandle<T>;
    registerProxy(proxy: T): void;
    removeResource(value: ResourceHandle<T> | T): void;
    registerLoop(handle: ResourceHandle<T>): ResourceHandle<T>;
    getLoop(rep: ResourceRepresentation): ResourceHandle<T>;
}
export declare namespace ResourceManager {
    const handleTag: symbol;
    class Default<T extends Resource = Resource> implements ResourceManager<T> {
        private handleCounter;
        private handleTable;
        private h2r;
        private finalizer;
        private ctor;
        private dtor;
        private representationCounter;
        private loopTable;
        constructor();
        newHandle(rep: ResourceRepresentation): ResourceHandle<T>;
        getRepresentation(handle: ResourceHandle<T>): ResourceRepresentation;
        dropHandle(handle: ResourceHandle<T>): ResourceRepresentation;
        setProxyInfo(ctor: (new (handleTag: symbol, handle: ResourceHandle<T>, rep: ResourceRepresentation) => T), dtor: (self: ResourceHandle<T>) => void): void;
        hasResource(handle: ResourceHandle<T>): boolean;
        getResource(handle: ResourceHandle<T>): T;
        registerResource(resource: T, handle?: ResourceHandle<T>): ResourceHandle<T>;
        registerProxy(proxy: T): void;
        removeResource(value: ResourceHandle<T> | T): void;
        registerLoop(handle: ResourceHandle<T>): ResourceHandle<T>;
        getLoop(rep: ResourceRepresentation): ResourceHandle<T>;
        private setProxy;
    }
    function from<T extends Resource = Resource>(obj: any | undefined): ResourceManager<T> | undefined;
}
export interface ResourceManagers {
    has(id: string): boolean;
    set(id: string, manager: ResourceManager): void;
    ensure<T extends Resource = Resource>(id: string): ResourceManager<T>;
    get<T extends Resource = Resource>(id: string): ResourceManager<T> | undefined;
}
export declare namespace ResourceManagers {
    class Default implements ResourceManagers {
        private readonly managers;
        constructor();
        has(id: string): boolean;
        set(id: string, manager: ResourceManager): void;
        ensure<T extends Resource = Resource>(id: string): ResourceManager<T>;
        get<T extends Resource = Resource>(id: string): ResourceManager<T> | undefined;
    }
    function is(value: any): value is ResourceManagers;
}
export type JType = number | bigint | string | boolean | JArray | JRecord | JVariantCase | JTuple | JEnum | Resource | option<any> | undefined | void | result<any, any> | Int8Array | Int16Array | Int32Array | BigInt64Array | Uint8Array | Uint16Array | Uint32Array | BigUint64Array | Float32Array | Float64Array;
export type CallableParameter = [/* name */ string, /* type */ AnyComponentModelType];
export type JFunction = (...params: JType[]) => JType;
export type JClass = {
    new (...params: JType[]): Resource;
    [key: string]: JFunction;
};
export type JFunctionAsync = (...params: JType[]) => Promise<JType> | JType;
export type JClassAsync = {
    $new(...params: JType[]): Promise<Resource>;
    [key: string]: JFunctionAsync;
};
export type WasmFunction = (...params: WasmType[]) => WasmType | void;
export interface WorkerConnection {
    dispose(): void;
    getMemory(): Memory;
    on(id: string, callback: (memory: Memory, params: WasmType[]) => WasmType | void): void;
    prepareCall(): void;
    callMain(name: string, params: ReadonlyArray<WasmType>): WasmType | void;
    listen(): void;
}
export type Code = WebAssembly_.Module | {
    module: WebAssembly_.Module;
    memory?: WebAssembly_.Memory;
};
export interface MainConnection {
    initialize(code: Code, options: Options): Promise<void>;
    dispose(): void;
    getMemory(): Memory;
    on(id: string, callback: (memory: Memory, params: WasmType[]) => WasmType | void | Promise<WasmType | void>): void;
    prepareCall(): void;
    lock(thunk: () => Promise<JType>): Promise<JType>;
    callWorker(name: string, params: ReadonlyArray<WasmType>): Promise<WasmType | void>;
    listen(): void;
}
declare class Callable {
    private static readonly EMPTY_JTYPE;
    private static readonly EMPTY_WASM_TYPE;
    static readonly MAX_FLAT_PARAMS = 16;
    static readonly MAX_FLAT_RESULTS = 1;
    readonly witName: string;
    readonly params: CallableParameter[];
    readonly returnType: AnyComponentModelType | undefined;
    readonly paramType: AnyComponentModelType | undefined;
    protected readonly isSingleParam: boolean;
    protected readonly mode: 'lift' | 'lower';
    constructor(witName: string, params: CallableParameter[], returnType?: AnyComponentModelType);
    protected liftParamValues(wasmValues: WasmType[], memory: Memory, context: ComponentModelContext): ReadonlyArray<JType>;
    protected lowerParamValues(values: JType[], memory: Memory, context: ComponentModelContext): ReadonlyArray<WasmType>;
    protected copyParamValues(result: WasmType[], dest: Memory, wasmValues: WasmType[], src: Memory, context: ComponentModelContext): {
        originalResult: MemoryRange;
        transferResult: MemoryRange;
    } | undefined;
    protected lowerReturnValue(value: JType | void, memory: Memory, context: ComponentModelContext, out: ptr | undefined): WasmType | void;
    protected handleError(error: any, memory: Memory, context: ComponentModelContext, out: ptr | undefined): WasmType | void;
    protected copyReturnValue(resultStorage: {
        originalResult: MemoryRange;
        transferResult: MemoryRange;
    } | undefined, dest: Memory, src: Memory, value: WasmType | undefined | void, context: ComponentModelContext): WasmType | undefined;
    /**
     * Calls a function inside a wasm module.
     */
    callWasm(params: JType[], wasmFunction: WasmFunction, context: WasmContext): JType;
    /**
     * Calls a resource method inside a wasm module.
     */
    callWasmMethod(obj: Resource & {
        $rep(): ResourceRepresentation;
    }, params: JType[], wasmFunction: WasmFunction, context: WasmContext): JType;
    /**
     * Call a host function on the main thread from a wasm module.
     */
    callMain(connection: WorkerConnection, qualifier: string, params: WasmType[], context: WasmContext): WasmType | void;
    /**
     * Call a wasm function from a worker thread.
     */
    callWasmFromWorker(transferMemory: Memory, func: WasmFunction, params: WasmType[], context: WasmContext): WasmType | void;
    /**
     * Call a wasm method from a worker thread.
     */
    callWasmMethodFromWorker(transferMemory: Memory, func: WasmFunction, params: WasmType[], context: WasmContext): WasmType | void;
    /**
     * Call the wasm function from the main thread.
     */
    callWorker(connection: MainConnection, qualifier: string, params: JType[], context: ComponentModelContext): Promise<JType | void>;
    /**
     * Call a resource method inside a wasm module.
     */
    callWorkerMethod(connection: MainConnection, qualifier: string, obj: Resource & {
        $rep(): ResourceRepresentation;
    }, params: JType[], context: ComponentModelContext): Promise<JType>;
    protected getParamValuesForHostCall(params: WasmType[], memory: Memory, context: ComponentModelContext): [ReadonlyArray<JType>, ptr | undefined];
    protected liftReturnValue(value: WasmType | void, memory: Memory, context: ComponentModelContext): JType;
}
export declare class FunctionType<_T extends Function = Function> extends Callable {
    constructor(witName: string, params: CallableParameter[], returnType?: AnyComponentModelType);
    /**
     * Calls a service function from a wasm module.
     */
    callService(func: JFunction, params: WasmType[], context: WasmContext): WasmType | void;
    callServiceAsync(memory: Memory, func: JFunctionAsync, params: WasmType[], context: ComponentModelContext): Promise<WasmType | void>;
}
export declare class ConstructorType<_T extends Function = Function> extends Callable {
    constructor(witName: string, params: CallableParameter[], returnType: AnyComponentModelType);
    callService(clazz: JClass, params: WasmType[], context: WasmContext): WasmType | void;
    callServiceAsync(memory: Memory, clazz: JClassAsync, params: WasmType[], context: ComponentModelContext): Promise<WasmType | void>;
    callWasmConstructor(params: JType[], wasmFunction: WasmFunction, context: WasmContext): number;
    callWasmConstructorAsync(connection: MainConnection, qualifier: string, params: JType[], context: ComponentModelContext): Promise<ResourceHandle>;
}
export declare class DestructorType<_T extends Function = Function> extends Callable {
    constructor(witName: string, params: CallableParameter[]);
    callService(params: WasmType[], resourceManager: ResourceManager): void;
    callServiceAsync(_memory: Memory, params: WasmType[], resourceManager: ResourceManager): Promise<void>;
}
export declare class StaticMethodType<_T extends Function = Function> extends Callable {
    constructor(witName: string, params: CallableParameter[], returnType?: AnyComponentModelType);
    callService(func: JFunction, params: WasmType[], context: WasmContext): WasmType | void;
    callServiceAsync(memory: Memory, func: JFunctionAsync, params: WasmType[], context: ComponentModelContext): Promise<WasmType | void>;
}
export declare class MethodType<_T extends Function = Function> extends Callable {
    constructor(witName: string, params: CallableParameter[], returnType?: AnyComponentModelType);
    callService(methodName: string, params: WasmType[], resourceManager: ResourceManager, context: WasmContext): WasmType | void;
    callServiceAsync(memory: Memory, methodName: string, params: WasmType[], resourceManager: ResourceManager, context: ComponentModelContext): Promise<WasmType | void>;
}
export type ResourceCallable<T extends JFunction = JFunction> = MethodType<T> | StaticMethodType<T> | ConstructorType<T> | DestructorType;
export type ResourceHandle<_T extends Resource = Resource> = u32;
export declare class ResourceHandleType implements ComponentModelType<ResourceHandle> {
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: readonly GenericFlatType[];
    readonly witName: string;
    constructor(witName: string);
    load(memory: ReadonlyMemoryRange, offset: offset): ResourceHandle;
    liftFlat(memory: Memory, values: FlatValuesIter): ResourceHandle;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, value: ResourceHandle): void;
    lowerFlat(result: WasmType[], memory: Memory, value: ResourceHandle): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory): void;
}
export declare class ResourceType<T extends Resource = Resource> implements ComponentModelType<T> {
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: readonly GenericFlatType[];
    readonly witName: string;
    readonly id: string;
    readonly callables: Map<string, ResourceCallable>;
    constructor(witName: string, id: string);
    addConstructor(jsName: string, func: ConstructorType): void;
    addDestructor(jsName: string, func: DestructorType): void;
    addStaticMethod(jsName: string, func: StaticMethodType): void;
    addMethod(jsName: string, func: MethodType): void;
    getCallable(jsName: string): ResourceCallable;
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): T;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, value: T): void;
    lowerFlat(result: WasmType[], memory: Memory, value: T): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory): void;
}
declare class AbstractWrapperType<T extends NonNullable<JType>> implements ComponentModelType<T> {
    readonly kind: ComponentModelTypeKind;
    readonly size: size;
    readonly alignment: Alignment;
    readonly flatTypes: readonly GenericFlatType[];
    private readonly wrapped;
    constructor(kind: ComponentModelTypeKind, wrapped: ComponentModelType<T>);
    load(memory: ReadonlyMemoryRange, offset: offset, context: ComponentModelContext): T;
    liftFlat(memory: Memory, values: FlatValuesIter, context: ComponentModelContext): T;
    alloc(memory: Memory): MemoryRange;
    store(memory: MemoryRange, offset: offset, value: T, context: ComponentModelContext): void;
    lowerFlat(result: WasmType[], memory: Memory, value: T, context: ComponentModelContext): void;
    copy(dest: MemoryRange, dest_offset: offset, src: ReadonlyMemoryRange, src_offset: offset, context: ComponentModelContext): void;
    copyFlat(result: WasmType[], dest: Memory, values: FlatValuesIter, src: Memory, context: ComponentModelContext): void;
}
export type borrow<T extends NonNullable<JType>> = T;
export declare class BorrowType<T extends NonNullable<JType>> extends AbstractWrapperType<T> {
    constructor(type: ComponentModelType<T>);
}
export type own<T extends NonNullable<JType>> = T;
export declare class OwnType<T extends NonNullable<JType>> extends AbstractWrapperType<T> {
    constructor(type: ComponentModelType<T>);
}
export type InterfaceType = {
    readonly id: string;
    readonly witName: string;
    readonly types?: Map<string, AnyComponentModelType>;
    readonly functions?: Map<string, FunctionType<JFunction>>;
    readonly resources?: Map<string, ResourceType>;
};
export declare namespace InterfaceType {
    function is(value: any): value is InterfaceType;
}
export type WasmModuleImports = Record<string, WasmFunction>;
export type WasmImports = Record<string, WasmModuleImports>;
export type WasmExports = Record<string, Function>;
export type ServiceInterface = Record<string, JFunction | JClass>;
export type WorldServiceInterface = Record<string, JFunction | ServiceInterface>;
export type ServiceInterfaceAsync = Record<string, JFunctionAsync | JClassAsync>;
export type WorldServiceInterfaceAsync = Record<string, JFunction | ServiceInterfaceAsync>;
type ServiceInterfaceImplementation = Record<string, Function | Record<string, Function> | {
    new (...params: any): Resource;
}>;
type WorldServiceInterfaceImplementation = Record<string, Function | ServiceInterfaceImplementation>;
type ServiceInterfaceImplementationAsync = Record<string, Function | Record<string, Function> | {
    $new(...params: any): Resource | Promise<Resource>;
}>;
type WorldServiceInterfaceImplementationAsync = Record<string, Function | ServiceInterfaceImplementationAsync>;
export type WorldType = {
    readonly id: string;
    readonly witName: string;
    readonly imports?: {
        readonly functions?: Map<string, FunctionType<JFunction>>;
        readonly interfaces?: Map<string, InterfaceType>;
        create?(service: any, context: WasmContext): any;
        loop?(service: any, context: WasmContext): any;
    };
    readonly exports?: {
        readonly functions?: Map<string, FunctionType<JFunction>>;
        readonly interfaces?: Map<string, InterfaceType>;
        bind?(service: any, context: WasmContext): any;
    };
    bind?(service: any, code: Code, context?: ComponentModelContext): Promise<any>;
    bind?(service: any, code: Code, port: RAL.ConnectionPort, context?: ComponentModelContext): Promise<any>;
};
export type PackageType = {
    readonly id: string;
    readonly witName: string;
    readonly interfaces?: Map<string, InterfaceType>;
    readonly worlds?: Map<string, WorldType>;
};
export declare namespace PackageType {
    function is(value: any): value is PackageType;
}
export interface WasmContext extends ComponentModelContext {
    getMemory(): Memory;
}
export declare namespace WasmContext {
    class Default implements WasmContext {
        private memory;
        readonly options: Options;
        readonly resources: ResourceManagers;
        constructor(options?: Options, resources?: ResourceManagers);
        initialize(memory: Memory): void;
        getMemory(): Memory;
    }
    function is(value: any): value is WasmContext;
}
export declare namespace $imports {
    type _Distribute<T> = T extends any ? _Promisify<T> : never;
    type _Required<T> = {
        [K in keyof T]-?: T[K] extends (...args: any[]) => any ? T[K] : T[K] extends object ? _Required<T[K]> : T[K];
    };
    type _Promisify<T> = {
        [K in keyof T]: T[K] extends (...args: infer A) => infer R ? K extends '$handle' ? T[K] : (...args: A) => Promise<R> | R : T[K] extends object ? _Distribute<T[K]> : T[K];
    };
    export type Promisify<T> = _Promisify<_Required<T>>;
    export function create<R>(world: WorldType, service: WorldServiceInterfaceImplementation, context: WasmContext): R;
    export function loop<R>(world: WorldType, service: WorldServiceInterfaceImplementation, context: WasmContext): R;
    export namespace worker {
        function create(connection: WorkerConnection, world: WorldType, context: WasmContext): WasmImports;
    }
    export {};
}
export declare namespace $exports {
    type _Distribute<T> = T extends any ? _Promisify<T> : never;
    type _Required<T> = {
        [K in keyof T]-?: T[K] extends (...args: any[]) => any ? T[K] : T[K] extends object ? _Required<T[K]> : T[K];
    };
    type _Promisify<T> = {
        [K in keyof T]: T[K] extends (...args: infer A) => infer R ? K extends '$new' ? (...arg: A) => Promise<_Promisify<R>> : (...args: A) => Promise<R> : T[K] extends object ? _Distribute<T[K]> : T[K];
    };
    export type Promisify<T> = _Promisify<_Required<T>>;
    export function bind<R>(world: WorldType, exports: WasmExports, context: WasmContext): R;
    export namespace worker {
        function bind(connection: WorkerConnection, world: WorldType, exports: WasmExports, context: WasmContext): void;
    }
    export {};
}
export declare namespace $main {
    function bind(world: WorldType, service: WorldServiceInterfaceImplementation | WorldServiceInterfaceImplementationAsync, code: Code, portOrContext?: ComponentModelContext | RAL.ConnectionPort, context?: ComponentModelContext): Promise<any>;
}
export {};
