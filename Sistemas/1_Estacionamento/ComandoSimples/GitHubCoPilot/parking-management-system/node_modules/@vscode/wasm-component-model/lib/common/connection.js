"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseMainConnection = exports.BaseWorkerConnection = exports.Connection = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/webAssemblyCommon.d.ts" preserve="true"/>
const uuid = __importStar(require("uuid"));
const componentModel_1 = require("./componentModel");
const promises_1 = require("./promises");
const ral_1 = __importDefault(require("./ral"));
const semaphore_1 = require("./semaphore");
class ConnectionMemory {
    static Header = {
        sync: { offset: 0, size: 4 },
        errorCode: { offset: 4, size: 4 },
        resultType: { offset: 8, size: 4 },
        result: { offset: 12, size: 8 },
        next: { offset: 20, size: 4 },
        end: { offset: 24, size: 0 },
    };
    buffer;
    id;
    next;
    constructor(sizeOrBuffer, id) {
        if (sizeOrBuffer === undefined) {
            sizeOrBuffer = 64 * 1024;
        }
        if (typeof sizeOrBuffer === 'number') {
            this.id = uuid.v4();
            this.buffer = new SharedArrayBuffer(sizeOrBuffer);
            this.next = new Uint32Array(this.buffer, ConnectionMemory.Header.next.offset, 1);
            this.next[0] = ConnectionMemory.Header.end.offset;
        }
        else {
            this.buffer = sizeOrBuffer;
            this.id = id;
            this.next = new Uint32Array(this.buffer, ConnectionMemory.Header.next.offset, 1);
        }
    }
    reset() {
        const view = new Uint8Array(this.buffer, 0, ConnectionMemory.Header.end.offset);
        view.fill(0);
        this.next[0] = ConnectionMemory.Header.end.offset;
    }
    alloc(align, size) {
        const next = this.next[0];
        const result = componentModel_1.Alignment.align(next, align);
        this.next[0] = result + size;
        return new componentModel_1.MemoryRange(this, result, size);
    }
    realloc() {
        throw new componentModel_1.ComponentModelTrap('ConnectionMemory does not support realloc');
    }
    preAllocated(ptr, size) {
        return new componentModel_1.MemoryRange(this, ptr, size);
    }
    readonly(ptr, size) {
        return new componentModel_1.ReadonlyMemoryRange(this, ptr, size);
    }
}
class Connection {
    static createWorker(world, port, timeout) {
        return (0, ral_1.default)().Connection.createWorker(port, world, timeout);
    }
    memory;
    constructor(memory) {
        this.memory = memory;
    }
    static serializeParams(params) {
        const result = [];
        for (const param of params) {
            if (typeof param === 'number') {
                result.push(param);
            }
            else {
                result.push(param.toString());
            }
        }
        return result;
    }
    static deserializeParams(params) {
        const result = [];
        for (const param of params) {
            if (typeof param === 'string') {
                result.push(BigInt(param));
            }
            else {
                result.push(param);
            }
        }
        return result;
    }
    static serializeResult(result) {
        if (typeof result === 'bigint') {
            return result.toString();
        }
        else if (typeof result === 'number') {
            return result;
        }
        return undefined;
    }
    static deserializeResult(result) {
        if (result === undefined) {
            return;
        }
        return typeof result === 'number' ? result : BigInt(result);
    }
    static loadResult(buffer) {
        const view = new DataView(buffer, 0, ConnectionMemory.Header.end.offset);
        const resultType = view.getUint32(ConnectionMemory.Header.resultType.offset, true);
        switch (resultType) {
            case Connection.WasmTypeKind.undefined:
                return;
            case Connection.WasmTypeKind.float:
                return view.getFloat64(ConnectionMemory.Header.result.offset, true);
            case Connection.WasmTypeKind.signed:
                return view.getBigInt64(ConnectionMemory.Header.result.offset, true);
            case Connection.WasmTypeKind.unsigned:
                return view.getBigUint64(ConnectionMemory.Header.result.offset, true);
            default:
                throw new componentModel_1.ComponentModelTrap(`Unexpected result type ${resultType}`);
        }
    }
    static storeResult(buffer, result) {
        const view = new DataView(buffer, 0, ConnectionMemory.Header.end.offset);
        if (result === undefined) {
            view.setUint32(ConnectionMemory.Header.resultType.offset, Connection.WasmTypeKind.undefined, true);
        }
        else if (typeof result === 'bigint') {
            if (result < 0) {
                view.setUint32(ConnectionMemory.Header.resultType.offset, Connection.WasmTypeKind.signed, true);
                view.setBigInt64(ConnectionMemory.Header.result.offset, result, true);
            }
            else {
                view.setUint32(ConnectionMemory.Header.resultType.offset, Connection.WasmTypeKind.unsigned, true);
                view.setBigUint64(ConnectionMemory.Header.result.offset, result, true);
            }
        }
        else if (typeof result === 'number') {
            view.setUint32(ConnectionMemory.Header.resultType.offset, Connection.WasmTypeKind.float, true);
            view.setFloat64(ConnectionMemory.Header.result.offset, result, true);
        }
        else {
            throw new componentModel_1.ComponentModelTrap(`Unexpected result type ${result}`);
        }
    }
}
exports.Connection = Connection;
(function (Connection) {
    let ErrorCodes;
    (function (ErrorCodes) {
        ErrorCodes[ErrorCodes["noHandler"] = 1] = "noHandler";
        ErrorCodes[ErrorCodes["promiseRejected"] = 2] = "promiseRejected";
    })(ErrorCodes = Connection.ErrorCodes || (Connection.ErrorCodes = {}));
    let WasmTypeKind;
    (function (WasmTypeKind) {
        WasmTypeKind[WasmTypeKind["undefined"] = 0] = "undefined";
        WasmTypeKind[WasmTypeKind["float"] = 1] = "float";
        WasmTypeKind[WasmTypeKind["signed"] = 2] = "signed";
        WasmTypeKind[WasmTypeKind["unsigned"] = 3] = "unsigned";
    })(WasmTypeKind = Connection.WasmTypeKind || (Connection.WasmTypeKind = {}));
})(Connection || (exports.Connection = Connection = {}));
class BaseWorkerConnection extends Connection {
    world;
    timeout;
    handlers;
    constructor(world, timeout) {
        super(new ConnectionMemory());
        this.world = world;
        this.timeout = timeout;
        this.handlers = new Map();
    }
    dispose() {
        this.handlers.clear();
    }
    on(name, handler) {
        this.handlers.set(name, handler);
    }
    getMemory() {
        return this.memory;
    }
    prepareCall() {
        this.memory.reset();
    }
    callMain(name, params) {
        const buffer = this.memory.buffer;
        const sync = new Int32Array(buffer, ConnectionMemory.Header.sync.offset, 1);
        Atomics.store(sync, 0, 0);
        const message = {
            method: 'callMain',
            name: name,
            params: Connection.serializeParams(params),
            memory: { buffer: this.memory.buffer, id: this.memory.id }
        };
        this.postMessage(message);
        // Wait for the answer
        const result = Atomics.wait(sync, 0, 0, this.timeout);
        switch (result) {
            case 'timed-out':
                throw new componentModel_1.ComponentModelTrap(`Call ${name} to main thread timed out`);
            case 'not-equal':
                const value = Atomics.load(sync, 0);
                // If the value === 1 the service has already provided the result.
                // Otherwise we actually don't know what happened :-(.
                if (value !== 1) {
                    throw new componentModel_1.ComponentModelTrap(`Unexpected value ${value} in sync object`);
                }
        }
        return Connection.loadResult(buffer);
    }
    handleMessage(message) {
        if (message.method === 'initializeWorker') {
            const wasmContext = new componentModel_1.WasmContext.Default(message.options);
            const imports = componentModel_1.$imports.worker.create(this, this.world, wasmContext);
            if (message.memory !== undefined) {
                imports.env.memory = message.memory;
            }
            (0, ral_1.default)().WebAssembly.instantiate(message.module, imports).then((instance) => {
                wasmContext.initialize(new componentModel_1.Memory.Default(instance.exports));
                componentModel_1.$exports.worker.bind(this, this.world, instance.exports, wasmContext);
                this.postMessage({ method: 'reportResult', name: '$initializeWorker', result: 'success' });
            }).catch((error) => {
                this.postMessage({ method: 'reportResult', name: '$initializeWorker', error: error.toString() });
            });
        }
        else if (message.method === 'callWorker') {
            const handler = this.handlers.get(message.name);
            if (handler === undefined) {
                this.postMessage({ method: 'reportResult', name: message.name, error: `No handler found for ${message.name}` });
                return;
            }
            try {
                const memory = new ConnectionMemory(message.memory.buffer, message.memory.id);
                const result = handler(memory, Connection.deserializeParams(message.params));
                this.postMessage({ method: 'reportResult', name: message.name, result: Connection.serializeResult(result) });
            }
            catch (error) {
                this.postMessage({ method: 'reportResult', name: message.name, error: `Calling WASM function ${message.name} failed.` });
            }
        }
    }
}
exports.BaseWorkerConnection = BaseWorkerConnection;
class BaseMainConnection extends Connection {
    initializeCall;
    handlers;
    callQueue;
    currentCall;
    constructor() {
        super(new ConnectionMemory());
        this.handlers = new Map();
        this.callQueue = new semaphore_1.Semaphore(1);
        this.currentCall = undefined;
    }
    dispose() {
        this.handlers.clear();
        this.callQueue.dispose();
    }
    lock(thunk) {
        return this.callQueue.lock(thunk);
    }
    prepareCall() {
        this.memory.reset();
    }
    getMemory() {
        return this.memory;
    }
    async initialize(code, options) {
        let module;
        let memory = undefined;
        if (code.module !== undefined) {
            module = code.module;
            memory = code.memory;
        }
        else {
            module = code;
        }
        return new Promise((resolve, reject) => {
            const message = {
                method: 'initializeWorker',
                module: module,
                memory: memory,
                options: options,
            };
            this.initializeCall = { resolve, reject };
            this.postMessage(message);
        });
    }
    callWorker(name, params) {
        if (this.currentCall !== undefined) {
            throw new componentModel_1.ComponentModelTrap('Call already in progress');
        }
        this.currentCall = promises_1.CapturedPromise.create();
        const message = {
            method: 'callWorker',
            name: name,
            params: Connection.serializeParams(params),
            memory: { buffer: this.memory.buffer, id: this.memory.id }
        };
        this.postMessage(message);
        return this.currentCall.promise;
    }
    on(id, handler) {
        this.handlers.set(id, handler);
    }
    handleMessage(message) {
        if (message.method === 'callMain') {
            const buffer = message.memory.buffer;
            const sync = new Int32Array(buffer, ConnectionMemory.Header.sync.offset, 1);
            const view = new DataView(buffer, 0, ConnectionMemory.Header.end.offset);
            const handler = this.handlers.get(message.name);
            if (handler === undefined) {
                view.setUint32(ConnectionMemory.Header.errorCode.offset, Connection.ErrorCodes.noHandler, true);
                Atomics.store(sync, 0, 1);
                Atomics.notify(sync, 0);
                return;
            }
            else {
                const memory = new ConnectionMemory(buffer, message.memory.id);
                const params = Connection.deserializeParams(message.params);
                const result = handler(memory, params);
                if (result instanceof Promise) {
                    result.then((value) => {
                        Connection.storeResult(buffer, value);
                    }).catch(() => {
                        view.setUint32(ConnectionMemory.Header.errorCode.offset, Connection.ErrorCodes.promiseRejected, true);
                    }).finally(() => {
                        Atomics.store(sync, 0, 1);
                        Atomics.notify(sync, 0);
                    });
                }
                else {
                    Connection.storeResult(buffer, result);
                    Atomics.store(sync, 0, 1);
                    Atomics.notify(sync, 0);
                }
            }
        }
        else if (message.method === 'reportResult') {
            if (message.name === '$initializeWorker') {
                if (this.initializeCall === undefined) {
                    // Need to think about logging this.
                    return;
                }
                if (message.error !== undefined) {
                    this.initializeCall.reject(new Error(message.error));
                }
                else {
                    this.initializeCall.resolve();
                }
                this.initializeCall = undefined;
            }
            else {
                if (this.currentCall === undefined) {
                    // Need to think about logging this.
                    return;
                }
                if (message.error !== undefined) {
                    this.currentCall.reject(new Error(message.error));
                }
                else {
                    const result = Connection.deserializeResult(message.result);
                    this.currentCall.resolve(result);
                }
                this.currentCall = undefined;
            }
        }
    }
}
exports.BaseMainConnection = BaseMainConnection;
