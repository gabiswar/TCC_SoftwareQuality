/// <reference path="../../typings/webAssemblyCommon.d.ts" preserve="true" />
import { Alignment, Memory, MemoryRange, ReadonlyMemoryRange, type Code, type JType, type MainConnection, type Options, type WasmType, type WorkerConnection, type WorldType } from './componentModel';
import RAL from './ral';
declare class ConnectionMemory implements Memory {
    static readonly Header: {
        sync: {
            offset: number;
            size: number;
        };
        errorCode: {
            offset: number;
            size: number;
        };
        resultType: {
            offset: number;
            size: number;
        };
        result: {
            offset: number;
            size: number;
        };
        next: {
            offset: number;
            size: number;
        };
        end: {
            offset: number;
            size: number;
        };
    };
    buffer: SharedArrayBuffer;
    readonly id: string;
    private next;
    constructor();
    constructor(size: number);
    constructor(buffer: SharedArrayBuffer, id: string);
    reset(): void;
    alloc(align: Alignment, size: number): MemoryRange;
    realloc(): MemoryRange;
    preAllocated(ptr: number, size: number): MemoryRange;
    readonly(ptr: number, size: number): ReadonlyMemoryRange;
}
export declare abstract class Connection {
    static createWorker(world: WorldType, port?: RAL.ConnectionPort, timeout?: number): Promise<WorkerConnection>;
    protected readonly memory: ConnectionMemory;
    constructor(memory: ConnectionMemory);
    protected static serializeParams(params: readonly WasmType[]): (number | string)[];
    protected static deserializeParams(params: readonly (string | number)[]): WasmType[];
    protected static serializeResult(result: WasmType | undefined | void): number | string | undefined;
    protected static deserializeResult(result: string | number | undefined): WasmType | void;
    protected static loadResult(buffer: SharedArrayBuffer): WasmType | void | undefined;
    protected static storeResult(buffer: SharedArrayBuffer, result: WasmType | void | undefined): void;
}
export declare namespace Connection {
    enum ErrorCodes {
        noHandler = 1,
        promiseRejected = 2
    }
    enum WasmTypeKind {
        undefined = 0,
        float = 1,
        signed = 2,
        unsigned = 3
    }
    type MainCallMessage = {
        readonly method: 'callMain';
        readonly name: string;
        readonly params: (number | string)[];
        readonly memory: {
            buffer: SharedArrayBuffer;
            id: string;
        };
    };
    type ReportResultMessage = {
        readonly method: 'reportResult';
        readonly name: string;
        readonly result?: number | string;
        readonly error?: string;
    };
    type MainMessages = MainCallMessage | ReportResultMessage;
    type InitializeWorker = {
        method: 'initializeWorker';
        readonly module: WebAssembly_.Module;
        readonly memory?: WebAssembly_.Memory;
        readonly options: Options;
    };
    type WorkerCallMessage = {
        readonly method: 'callWorker';
        readonly name: string;
        readonly params: (number | string)[];
        readonly memory: {
            buffer: SharedArrayBuffer;
            id: string;
        };
    };
    type WorkerMessages = InitializeWorker | WorkerCallMessage;
}
export declare abstract class BaseWorkerConnection extends Connection implements WorkerConnection {
    private readonly world;
    private readonly timeout;
    private readonly handlers;
    constructor(world: WorldType, timeout?: number);
    dispose(): void;
    on(name: string, handler: (memory: Memory, params: WasmType[]) => WasmType | void): void;
    getMemory(): Memory;
    prepareCall(): void;
    callMain(name: string, params: WasmType[]): WasmType | void;
    protected abstract postMessage(message: Connection.MainMessages): void;
    protected handleMessage(message: Connection.WorkerMessages): void;
    abstract listen(): void;
}
export declare abstract class BaseMainConnection extends Connection implements MainConnection {
    private initializeCall;
    private readonly handlers;
    private readonly callQueue;
    private currentCall;
    constructor();
    dispose(): void;
    lock(thunk: () => Promise<JType>): Promise<JType>;
    prepareCall(): void;
    getMemory(): Memory;
    initialize(code: Code, options: Options): Promise<void>;
    callWorker(name: string, params: WasmType[]): Promise<WasmType | void>;
    on(id: string, handler: (memory: Memory, params: WasmType[]) => WasmType | void | Promise<WasmType | void>): void;
    protected abstract postMessage(message: Connection.WorkerMessages): void;
    protected handleMessage(message: Connection.MainMessages): void;
    abstract listen(): void;
}
export {};
